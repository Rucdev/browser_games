<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スプライトアニメーションテスト</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #555;
            background: linear-gradient(to bottom, #87CEEB, #98FB98);
        }
        .controls {
            margin: 20px 0;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .info {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>スプライトシートアニメーションテスト</h1>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <div class="controls">
        <button onclick="startRunningAnimation()">走行アニメーション開始</button>
        <button onclick="startAttackAnimation()">攻撃アニメーション開始</button>
        <button onclick="stopAnimation()">アニメーション停止</button>
        <button onclick="toggleFlip()">左右反転</button>
    </div>

    <div class="info">
        <div>現在のアニメーション: <span id="currentAnimation">なし</span></div>
        <div>アニメーション状態: <span id="animationStatus">停止</span></div>
        <div>現在のフレーム: <span id="currentFrame">-</span></div>
    </div>

    <script type="module">
        // sprites.tsから必要な機能をインポート（実際の実装では適切にインポート）

        // SpriteAnimator クラスの簡易実装（テスト用）
        class SpriteAnimator {
            constructor(spriteSheet) {
                this.spriteSheet = spriteSheet;
                this.currentAnimation = null;
                this.currentFrameIndex = 0;
                this.frameStartTime = 0;
                this.isPlaying = false;
                this.hasFinished = false;
                this.loadedImages = new Map();
            }

            async loadImage(imagePath) {
                if (this.loadedImages.has(imagePath)) {
                    return this.loadedImages.get(imagePath);
                }

                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        this.loadedImages.set(imagePath, img);
                        resolve(img);
                    };
                    img.onerror = reject;
                    // テスト用のプレースホルダー画像を作成
                    img.src = this.createTestImage();
                });
            }

            createTestImage() {
                const canvas = document.createElement('canvas');
                canvas.width = 320;
                canvas.height = 144;
                const ctx = canvas.getContext('2d');

                // テスト用のスプライトシートを描画
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3'];

                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 10; col++) {
                        ctx.fillStyle = colors[(row * 10 + col) % colors.length];
                        ctx.fillRect(col * 32, row * 48, 32, 48);

                        // フレーム番号を描画
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${row * 10 + col}`, col * 32 + 16, row * 48 + 28);
                    }
                }

                return canvas.toDataURL();
            }

            startAnimation(animationName) {
                if (!this.spriteSheet.animations) return false;

                const animation = this.spriteSheet.animations[animationName];
                if (!animation) return false;

                this.currentAnimation = animation;
                this.currentFrameIndex = 0;
                this.frameStartTime = performance.now();
                this.isPlaying = true;
                this.hasFinished = false;
                return true;
            }

            stopAnimation() {
                this.isPlaying = false;
                this.currentAnimation = null;
                this.hasFinished = false;
            }

            update(currentTime) {
                if (!this.isPlaying || !this.currentAnimation) return;

                const currentFrame = this.currentAnimation.frames[this.currentFrameIndex];
                const frameDuration = currentFrame?.duration || this.currentAnimation.defaultFrameDuration || 100;

                if (currentTime - this.frameStartTime >= frameDuration) {
                    this.currentFrameIndex++;
                    this.frameStartTime = currentTime;

                    if (this.currentFrameIndex >= this.currentAnimation.frames.length) {
                        if (this.currentAnimation.loop) {
                            this.currentFrameIndex = 0;
                        } else {
                            this.currentFrameIndex = this.currentAnimation.frames.length - 1;
                            this.hasFinished = true;
                            this.isPlaying = false;
                        }
                    }
                }
            }

            getCurrentFrame() {
                if (!this.currentAnimation || this.currentAnimation.frames.length === 0) {
                    return null;
                }

                const animFrame = this.currentAnimation.frames[this.currentFrameIndex];
                return animFrame ? animFrame.frame : null;
            }

            isFinished() {
                return this.hasFinished;
            }

            isAnimationPlaying() {
                return this.isPlaying;
            }

            drawAnimatedSprite(ctx, x, y, flipX = false) {
                const frame = this.getCurrentFrame();
                if (!frame) return;

                const image = this.loadedImages.get(this.spriteSheet.imagePath);
                if (!image) return;

                ctx.save();

                if (flipX) {
                    ctx.scale(-1, 1);
                    ctx.translate(-x - frame.width, 0);
                }

                ctx.drawImage(
                    image,
                    frame.x,
                    frame.y,
                    frame.width,
                    frame.height,
                    flipX ? 0 : x,
                    y,
                    frame.width,
                    frame.height
                );

                ctx.restore();
            }
        }

        // テスト用のスプライトシート設定
        const testSpriteSheet = {
            imagePath: 'test_sprites.png',
            frameWidth: 32,
            frameHeight: 48,
            frames: {
                idle: { x: 0, y: 0, width: 32, height: 48 },
                running: { x: 32, y: 0, width: 32, height: 48 },
                jumping: { x: 64, y: 0, width: 32, height: 48 },
                attacking: { x: 96, y: 0, width: 32, height: 48 }
            },
            animations: {
                running: {
                    name: 'running',
                    loop: true,
                    defaultFrameDuration: 300,
                    frames: [
                        { frame: { x: 32, y: 0, width: 32, height: 48 }, duration: 300 },
                        { frame: { x: 64, y: 48, width: 32, height: 48 }, duration: 300 },
                        { frame: { x: 96, y: 48, width: 32, height: 48 }, duration: 300 },
                        { frame: { x: 128, y: 48, width: 32, height: 48 }, duration: 300 }
                    ]
                },
                attacking: {
                    name: 'attacking',
                    loop: false,
                    defaultFrameDuration: 120,
                    frames: [
                        { frame: { x: 96, y: 0, width: 32, height: 48 }, duration: 120 },
                        { frame: { x: 96, y: 48, width: 32, height: 48 }, duration: 200 },
                        { frame: { x: 96, y: 96, width: 32, height: 48 }, duration: 120 },
                        { frame: { x: 128, y: 96, width: 32, height: 48 }, duration: 100 }
                    ]
                }
            }
        };

        // ゲーム状態
        let animator;
        let flipX = false;
        let lastTime = 0;

        // キャンバス設定
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 初期化
        async function init() {
            animator = new SpriteAnimator(testSpriteSheet);
            await animator.loadImage(testSpriteSheet.imagePath);

            // アニメーションループ開始
            requestAnimationFrame(gameLoop);
        }

        // ゲームループ
        function gameLoop(currentTime) {
            // フレームレート制御
            if (currentTime - lastTime < 16) {
                requestAnimationFrame(gameLoop);
                return;
            }
            lastTime = currentTime;

            // アニメーション更新
            animator.update(currentTime);

            // 画面クリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 背景
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // スプライト描画
            const centerX = canvas.width / 2 - 16;
            const centerY = canvas.height / 2 - 24;
            animator.drawAnimatedSprite(ctx, centerX, centerY, flipX);

            // UI更新
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        // UI更新
        function updateUI() {
            document.getElementById('currentAnimation').textContent =
                animator.currentAnimation?.name || 'なし';
            document.getElementById('animationStatus').textContent =
                animator.isAnimationPlaying() ? '再生中' : '停止';
            document.getElementById('currentFrame').textContent =
                animator.currentAnimation ? `${animator.currentFrameIndex + 1}/${animator.currentAnimation.frames.length}` : '-';
        }

        // コントロール関数
        window.startRunningAnimation = () => {
            animator.startAnimation('running');
        };

        window.startAttackAnimation = () => {
            animator.startAnimation('attacking');
        };

        window.stopAnimation = () => {
            animator.stopAnimation();
        };

        window.toggleFlip = () => {
            flipX = !flipX;
        };

        // 初期化実行
        init();
    </script>
</body>
</html>